Require Import Coqlib.
Require Import ITreelib.
Require Import Any.
Require Import STS.
Require Import Behavior.
Require Import ModSem.
Require Import Skeleton.
Require Import PCM.
Require Import Coq.Relations.Relation_Definitions.
Require Import Relation_Operators.
Require Import RelationPairs.
From Ordinal Require Import Ordinal Arithmetic.
Require Import SimSTS.

Set Implicit Arguments.


CoInductive conat: Type :=
| O: conat
| S: conat -> conat
.

(*
inf, ?
?, inf
fin & even, fin & even
*)
Variant _is_even (is_even: conat -> conat -> Prop): conat -> conat -> Prop :=
| is_even_O: _is_even is_even O O
| is_even_l: forall n m, is_even n m -> _is_even is_even (S (S n)) m
| is_even_r: forall n m, is_even n m -> _is_even is_even n (S (S m))
.

Definition is_even: _ -> _ -> Prop := paco2 _is_even bot2.

#[global] Hint Constructors _is_even.
Hint Unfold is_even.

Lemma is_even_mon: monotone2 _is_even.
Proof.
  ii. induction IN; ss; eauto.
Qed.
Hint Resolve is_even_mon: paco.

Section CONT.
  Variable T0 : Type.
  Variable T1 : forall (x0: @T0), Type.

  Definition cont2 (gf: rel2 T0 T1 -> rel2 T0 T1) :=
    forall x0 x1 A B (IN: gf (A \2/ B) x0 x1), (gf A \2/ gf B) x0 x1.

  Definition cont2_rev (gf: rel2 T0 T1 -> rel2 T0 T1) :=
    forall x0 x1 A B (IN: (gf A \2/ gf B) x0 x1), gf (A \2/ B) x0 x1.

  Lemma mono_cont2_rev gf (MON: monotone2 gf): cont2_rev gf.
  Proof. ii. des; eapply MON; eauto. Qed.
End CONT.

Lemma is_even_cont: cont2 _is_even.
Proof.
  ii. inv IN; eauto.
  - des.
    + left. econs; eauto.
    + right. econs; eauto.
  - des.
    + left. econs; eauto.
    + right. econs; eauto.
Qed.

Notation "p -2> q" :=
  (fun x0 x1 => forall (PR: p x0 x1 : Prop), q x0 x1 : Prop)
  (at level 51, right associativity).
Notation "p -3> q" :=
  (fun x0 x1 x2 => forall (PR: p x0 x1 x2 : Prop), q x0 x1 x2 : Prop)
  (at level 51, right associativity).

Definition _is_evenL (is_even: conat -> conat -> Prop) (n m: conat): Prop :=
  (exists n', n = S (S n') /\ is_even n' m)
.

Section MINKI.
  Definition _is_evenL_e (is_even: conat -> conat -> Prop) (n m: conat): Prop :=
    is_even (S (S n)) m.

  Lemma WRES: wrespectful2 _is_even _is_evenL.
  Proof.
    econs; eauto.
    { admit "ez". }
    i. inv PR. des. subst.
    econs; eauto. eapply rclo2_base. eauto.
  Qed.

  Lemma WRES_e: wrespectful2 _is_even _is_evenL_e.
  Proof.
    econs; eauto.
    { admit "ez". }
    i. (* set (N:=x0). set(m:=x1). *)
    r in PR. dup PR. eapply GF in PR. eapply LE in PR0. inv PR.
    { (* unprovable when x0 = 1 *)
      admit "??". }
  Abort.

  Goal _is_evenL_e <*> (cpn2 _is_even) <3= (cpn2 _is_even).
  Proof.
    ii. r in PR. eapply cpn2_cpn.
    { admit "ez". }
    eapply wrespect2_companion; eauto.
    { admit "ez". }
  (*   { eapply WRES. } *)
  (*   r in PR. *)
  (* Qed. *)
  Abort.

End MINKI.

Definition _is_evenL_cond (n m: conat): Prop := (exists n', n = S (S n')).

Definition is_evenL (is_even: conat -> conat -> Prop) : conat -> conat -> Prop := _is_evenL_cond -2> _is_evenL is_even.

Lemma compat
  :
  is_evenL <*> _is_even <3= _is_even <*> is_evenL
.
Proof.
  ii. unfold compose in *.
  rr in PR.
  (* if x1 is (S O), it does not help here. *)
Abort.

Lemma decompat
  :
  _is_even <*> is_evenL <3= is_evenL <*> _is_even
.
Proof.
  ii. unfold compose in *.
  rr in PR0. des. subst.
  rr. esplits; eauto.
  inv PR; ss.
  (* if n' is not even it does not hold *)
Abort.

(* maybe the theory needs to recognize conditions? *)

Lemma decompat
  :
  (_is_even \3/ id) <*> _is_evenL <3= _is_evenL <*> (_is_even \3/ id)
.
Abort.
(* it does not help *)

Lemma decompat
  :
  (* forall r n m (COND: _is_evenL_cond n m), ((_is_even <*> _is_evenL) r n m) <0= ((_is_evenL <*> _is_even) r n m) *)
  ((fun _ => _is_evenL_cond) /3\ ((_is_even <*> _is_evenL)) <3= (_is_evenL <*> _is_even))
.
Proof.
  i. unfold compose in *. des.
  inv PR.
  rr. esplits; eauto.
  inv PR0; ss.
  - rr in H0. des. subst. econs; eauto.
  - rr in H. des. clarify. econs; eauto.
Qed.

Lemma compat
  :
  forall r n m (COND: _is_evenL_cond n m), ((_is_evenL <*> _is_even) r n m) <0= ((_is_even <*> _is_evenL) r n m)
.
Proof.
  i. unfold compose in *.
  inv COND.
  rr in PR. des. clarify. inv PR0.
  - econs; eauto. econs; eauto. Abort.


Theorem is_evenL_simpl
  :
  paco2 _is_even bot2 <2= is_evenL (upaco2 _is_even bot2)
.
Proof.
  i. punfold PR. induction PR.
  - ii. rr in PR. des; ss.
  - r in H. des; ss.
    + ii. inv PR. clarify. econs; eauto.
  - r in H. des; ss.
    + ii. inv PR. r. esplits; eauto. left.
      { revert_until m. revert m. pcofix CIH.
        i. punfold H0. inv H0.
        - r in H1. des; ss.
          { pfold. econs; eauto. left. eapply paco2_mon; eauto. ii; ss. }
        - r in H. des; ss.
          { pfold. econs; eauto. }
      }
Qed.

Theorem is_evenB_spec2
  r
  :
  paco2 _is_even r <2= is_evenL (upaco2 _is_even r)
.
Proof.
  i. punfold PR. induction PR.
  - ii. rr in PR. des; ss.
  - r in H. des.
    + ii. inv PR. clarify. econs; eauto.
    + ii. inv PR. clarify. econs; eauto.
  - r in H. des.
    + ii. inv PR. r. esplits; eauto. left.
      { revert_until r. pcofix CIH.
        i. punfold H0. inv H0.
        - r in H1. des.
          { pfold. econs; eauto. left. eapply paco2_mon; eauto. }
          { pfold. econs; eauto. }
        - r in H. des.
          { pfold. econs; eauto. }
          { pfold. econs; eauto. right. eapply CIH.
            pfold. econs; eauto. left. admit "??? do we need respectful?".
          }
      }
    + ii. rr in PR. des; subst. rr. esplits; eauto. left. pfold. econs; eauto.
Abort.

(*
y <= ftx      f compat (f <= t)
----------------------------------
y <= tx


y <= ux
----------------------------------
y <= fux      f dcompat (f <= u)
*)


Module THEORY. Section THEORY.
  Variable T0 : Type.
  Variable T1 : forall (x0: @T0), Type.

  Local Notation rel := (rel2 T0 T1).

  Variable gf: rel -> rel.
  Hypothesis gf_mon: monotone2 gf.

  Goal cpn2 gf = cpn2 (gf /3\ id).
  Proof.
    assert(Y: cpn2 gf <3= cpn2 (gf /3\ id)).
    { i. inv PR. econs; eauto. inv COM. econs; eauto.
      ii. split.
      + eapply compat2_compat; eauto. eapply compat2_mon; eauto. ii. ss; des; ss.
      + rr. eapply compat2_mon; eauto. ii. ss; des; ss.
    }
    extensionality r.
    extensionality x0.
    extensionality x1.
    assert(MON': monotone2 (gf /3\ id)).
    { ii. des. esplits; et. }
    apply prop_ext.
    split; i; et.
    - eapply cpn2_greatest; eauto. econs; eauto.
      { eapply cpn2_mon; eauto. }
      clear H. clear x1. clear x0. clear r.
      assert(T: gf <3= (gf /3\ id) <*> cpn2 gf).
      { ii. rr. split; i.
        - eapply gf_mon; eauto. ii. eapply cpn2_base; eauto.
        - rr. eapply cpn2_step; eauto. eapply gf_mon; eauto. ii. eapply cpn2_base; et.
      }
      ii.
      assert(U: (cpn2 (gf /3\ id) <*> (gf /3\ id) <*> cpn2 gf) r x0 x1).
      { eapply cpn2_mon; eauto. eapply T. }
      assert(V: ((gf /3\ id) <*> cpn2 (gf /3\ id) <*> cpn2 gf) r x0 x1).
      { assert(X:=cpn2_compat MON'). inv X. eapply compat2_compat in U. eauto. }
      assert(W: ((gf /3\ id) <*> cpn2 (gf /3\ id) <*> cpn2 (gf /3\ id)) r x0 x1).
      { eapply MON'; eauto. i. eapply cpn2_mon; eauto. }
      assert(X: ((gf /3\ id) <*> cpn2 (gf /3\ id)) r x0 x1).
      { eapply MON'; eauto. i. eapply cpn2_cpn; eauto. }
      rr in X. des; ss.
  Qed.

  Structure dcompatible2 (clo: rel -> rel) : Prop :=
    dcompat2_intro {
        dcompat2_mon: monotone2 clo;
        dcompat2_dcompat : forall r,
          gf (clo r) <2= clo (gf r);
      }.
  
  Variant cpn2 (r: rel) x0 x1 : Prop :=
  | cpn2_intro
      clo
      (COM: compatible2 gf clo)
      (CLO: clo r x0 x1)
  .
  Check (cpn2: rel -> rel).

  (* Variant U (R: rel -> rel) r x0 x1 : Prop := *)
  (* | cpn2_intro *)
  (*     clo *)
  (*     (COM: compatible2 gf clo) *)
  (*     (CLO: clo r x0 x1) *)
  (* . *)

End THEORY. End THEORY.

From Ordinal Require Import ClassicalOrdinal.

(*
tx = ‚ãÅ_{u f ‚â§ f u} u
Goal: ‚àÄ x. tx = ‚ãÄ_{x ‚â§ f_a} f_a

(i) ‚àÄ x. tx ‚â§ ‚ãÄ_{x ‚â§ f_a} f_a
<=> ‚àÄ x a, x ‚â§ f_a -> tx ‚â§ f_a
<=> ‚àÄ x a u, x ‚â§ f_a -> (uf ‚â§ fu) -> ux ‚â§ f_a

uf ‚â§ fu
--------------------------
‚àÄ a x, x ‚â§ f_a -> ux ‚â§ f_a

Use transifinite induction on a.
- a = O. trivial. ‚àé
- a = S b.
  IH: ‚àÄ x. x ‚â§ f_b -> ux ‚â§ f_b
  WTS: ‚àÄ x. x ‚â§ f f_b -> ux ‚â§ f f_b
  ux ‚â§ u f f_b (by premise)
     ‚â§ f u f_b (by compat)
     ‚â§ f f_b (by IH, put x <-| f_b) ‚àé
- a = Œª.
  IH: ‚àÄ x o. o < Œª -> x ‚â§ f_o -> ux ‚â§ f_o
  WTS: ‚àÄ x. x ‚â§ (‚ãÄ_{o < Œª} f_o) -> ux ‚â§ (‚ãÄ_{o < Œª} f_o)
  ux ‚â§ u (‚ãÄ_{o < Œª} f_o) (by premise)
  ETS. u (‚ãÄ_{o < Œª} f_o) ‚â§ (‚ãÄ_{o < Œª} f_o)
<=> ‚àÄ o < Œª. u (‚ãÄ_{o < Œª} f_o) ‚â§ f_o
<=  ‚àÄ o < Œª. u f_o ‚â§ f_o (SCOTT-CONT exploited?!)
This holds by IH (put x <-| f_o). ‚àé

(ii)
It suffices to show (fun x -> ‚ãÄ_{x ‚â§ f_a} f_a) is compatible.
(fun x -> ‚ãÄ_{x ‚â§ f_a} f_a) f ‚â§ f (fun x -> ‚ãÄ_{x ‚â§ f_a} f_a)
<=> ‚àÄ x. ‚ãÄ_{f x ‚â§ f_a} f_a ‚â§ f (‚ãÄ_{x ‚â§ f_a} f_a)

It is known that
(not exactly this form, but the idea of using Hartog's number will apply here too: https://arxiv.org/pdf/1605.04136.pdf)
such a sequence is stationary (it has its limit on the sequence itself).
let f_Œµ0 := ‚ãÄ_{f x ‚â§ f_a}.
let f_Œµ1 := ‚ãÄ_{x ‚â§ f_a}.
Now, ETS: ‚àÄ x. f_Œµ0 ‚â§ f f_Œµ1 = f_(S Œµ1)
Now, either Œµ0 ‚â§ S Œµ1 or S Œµ1 ‚â§ Œµ0 holds.
In either case, it is known that (by transfinite induction) (‚àÄ Œµ0 ‚â§ ùõº. f_Œµ0 = f_ùõº) and (‚àÄ Œµ1 ‚â§ ùõº. f_Œµ1 = f_ùõº). ‚àé


---------------------------------------------scratch------------------------------------------------


(ii) ‚àÄ x. ‚ãÄ_{x ‚â§ f_a} f_a ‚â§ tx
<=  ‚àÄ x. (‚ãÄ_{x ‚â§ f_a} f_a) f ‚â§ f (‚ãÄ_{x ‚â§ f_a} f_a) (by greatest-compat)
<=  ‚àÄ x a. x ‚â§ f_a. f_a f ‚â§ f f_a

Use transfinite induction on a.
- a = O. ‚ä§ f ‚â§ f ‚ä§. ?? type error.


(ii) ‚àÄ x. ‚ãÄ_{x ‚â§ f_a} f_a ‚â§ tx
First, we have: ùúàf = t‚ä• ‚â§ tx.
Thus, it suffices to show:
‚àÄ x. ‚ãÄ_{x ‚â§ f_a} f_a ‚â§ ùúàf
By Kleene's fixpoint theorem (Cousot's version), we have
ùúàf = ‚ãÄ f_a... dead end.
*)

(*
Goal: ‚àÄ d. f d ‚â§ d f -> tx ‚â§ dtx
First, unfold tx with Kleene-style stratification.
ETS: ‚ãÄ_{x ‚â§ f_a} f_a ‚â§ d ‚ãÄ_{x ‚â§ f_a} f_a
<=> f_Œµ ‚â§ d f_Œµ


‚àÄ u. u f ‚â§ f u -> utx ‚â§ tx
u f^o ‚ä§ <= f^o (u ‚ä§) ‚â§ f^o ‚ä§

dead end...

y ‚â§ tx -> y ‚â§ dtx
<=> (‚àÄ x ‚â§ f_a, y ‚â§ f_a) -> y ‚â§ d ‚ãÄ_{x ‚â§ f_a} f_a

‚àÄ x ‚â§ f_a. y ‚â§ f_a <=> y ‚â§ ‚ãÄ_{x ‚â§ f_a} f_a
*)

(*
Q: Dx = ‚ãÅ_{f_a ‚â§ x} f_a (starting from bot)??
Ïù¥Í≤å ÏÑ±Î¶ΩÌïòÎ©¥ U/D Ï†ÄÎ†áÍ≤å ÌïòÎäîÍ±∞Îäî dead end Ïùº Í≤ÉÏù¥Í≥†.

S caseÏóê f ÏïûÏóê Î∂ôÏù¥ÎÉê Îí§Ïóê Î∂ôÏù¥ÎÉêÎèÑ Îã§Î•ºÎ†§ÎÇò? Îí§Ïóê Î∂ôÏù¥Î©¥ Í∑∏Í±¥ Î≠êÏßÄ...

knowledge ÏïàÏóê DÎ•º Ïπ†Ìï¥ÎÜìÎäî Î∞©Î≤ïÏùÑ ÏÉùÍ∞ÅÌï¥Î¥êÏïº Ìï† Í≤É Í∞ôÏùå.
*)

(*
Dx = ‚ãÄ_{f d ‚â§ d f} d
Goal: ‚àÄ x. Dx = ‚ãÅ_{f_a ‚â§ x} f_a

f_a := match a with
       | O => ‚ä•
       | S b => f f_b
       | Œª => ‚ãÅ_{ùõº ‚â§ Œª} f_ùõº

(i) ‚àÄ x. Dx ‚â§ ‚ãÅ_{f_a ‚â§ x} f_a
It suffices to show (fun x -> ‚ãÅ_{f_a ‚â§ x} f_a) is dcompatible.
f (fun x -> ‚ãÅ_{f_a ‚â§ x} f_a) ‚â§ (fun x -> ‚ãÅ_{f_a ‚â§ x} f_a) f
<=> ‚àÄ x. f (‚ãÅ_{f_a ‚â§ x} f_a) ‚â§ ‚ãÅ_{f_a ‚â§ f x} f_a

It is known that
(not exactly this form, but the idea of using Hartog's number will apply here too: https://arxiv.org/pdf/1605.04136.pdf)
such a sequence is stationary (it has its limit on the sequence itself).
let f_Œµ0 := ‚ãÅ_{f_a ‚â§ x}.
let f_Œµ1 := ‚ãÅ_{f a ‚â§ f_x}.
Now, ETS: ‚àÄ x. f_(S Œµ0) = f f_Œµ0 ‚â§ f_Œµ1
Now, either S Œµ0 ‚â§ Œµ1 or Œµ1 ‚â§ S Œµ0 holds.
In either case, it is known that (by transfinite induction) (‚àÄ Œµ0 ‚â§ ùõº. f_Œµ0 = f_ùõº) and (‚àÄ Œµ1 ‚â§ ùõº. f_Œµ1 = f_ùõº). ‚àé

Q: Î¨¥Ïä® Î¨¥Ïä® ÏÑ±ÏßàÏùÑ Ïì¥Í±∞ÏßÄ..? ‚àÄ x. Ux ‚â§ ‚ãÅ_{f_a ‚â§ x} f_a Îäî ÏÑ±Î¶Ω ÏïàÌï¥Ïïº Ìï†ÌÖêÎç∞ Ïñ¥ÎîîÏÑú ÎßâÌûàÏßÄ?
A: RHSÍ∞Ä compatibleÌïòÎã§ÎäîÍ±∞ Î≥¥Ïù¥Î©¥ RHS <= UxÍ∞Ä Îê®...

(ii) ‚àÄ x. ‚ãÅ_{f_a ‚â§ x} f_a ‚â§ Dx
<=> ‚àÄ x a, f_a ‚â§ x -> f_a ‚â§ Dx
<=> ‚àÄ x a d, f a ‚â§ x -> (fd ‚â§ df) -> f_a ‚â§ dx

fd ‚â§ df
--------------------------
‚àÄ a x, f a ‚â§ x -> f_a ‚â§ dx

Use transifinite induction on a.
- a = O. trivial. ‚àé
- a = S b.
  IH: ‚àÄ x. f_b ‚â§ x -> f_b ‚â§ dx
  WTS: ‚àÄ x. f f_b ‚â§ x -> f f_b ‚â§ dx
  dx ‚â• d f f_b (by premise)
     ‚â• f d f_b (by dcompat)
     ‚â• f f_b (by IH, put x <-| f_b) ‚àé
- a = Œª.
  IH: ‚àÄ x o. o < Œª -> f_o ‚â§ x -> f_o ‚â§ dx
  WTS: ‚àÄ x. (‚ãÅ_{o < Œª} f_o) ‚â§ x -> (‚ãÄ_{o < Œª} f_o) ‚â§ dx
  dx ‚â• d (‚ãÅ_{o < Œª} f_o) (by premise)
  ETS. d (‚ãÅ_{o < Œª} f_o) ‚â• (‚ãÅ_{o < Œª} f_o)
<=> ‚àÄ o < Œª. d (‚ãÄ_{o < Œª} f_o) ‚â• f_o
<=  ‚àÄ o < Œª. d f_o ‚â§‚â• f_o (SCOTT-CONT exploited?!)
This holds by IH (put x <-| f_o). ‚àé
*)
u f_Œµ x ‚â§ f_Œµ x
<= f_Œµ u x ‚â§ f_Œµ x (transifinite induction, compat)‚â§ 

Section TREC.
  Variable D: Type.
  Variable base: D.
  Variable next: D -> D.
  (* Variable djoin: forall (Œª: Ord.t) (ds: { o: Ord.t | (o < Œª)%ord } -> D), D. *)
  Variable djoin: forall (ds: Ord.t -> D), D.

  (* Let dunion (d0 d1: D): D := djoin (fun b: bool => if b then d0 else d1). *)

  Fixpoint trec (o: Ord.t): D :=
    match o with
    | @Ord.build X os =>
        (* dunion base *)
          (djoin (fun o => next (trec o)))
    end.

  Definition trec (o: Ord.t): D.
    eapply Ord.rec.
    { eapply base. }
    { eapply next. }
    2: { eapply o. }
    i. eapply djoin.
    instantiate (1:=@Ord.build A ds).
  Defined.
End TREC.
Ord.orec : Ord.t -> (Ord.t -> Ord.t) -> Ord.t -> Ord.t
Ord.rec : forall [D : Type], D -> (D -> D) -> (forall A : Type, (A -> D) -> D) -> Ord.t -> D


Module THEORY2. Section THEORY.
  Variable T0 : Type.
  Variable T1 : forall (x0: @T0), Type.

  Local Notation rel := (rel2 T0 T1).

  Variable gf: rel -> rel.
  Hypothesis gf_mon: monotone2 gf.

  Definition forall2 (A: Type) (P: A -> rel): rel := fun x0 x1 => forall (a: A), P a x0 x1.
  (* Notation forall2 := (fun (A: Type) (P: A -> rel) x0 x1 => forall (a: A), P a x0 x1). *)
  Notation "'forall2' x .. y , p" := (forall2 (fun x => .. (forall2 (fun y => p)) ..))
                                      (at level 200, x binder, right associativity,
                                        format "'[' 'forall2'  '/  ' x  ..  y ,  '/  ' p ']'").
  (* Notation "'forall2' a , P" := (forall2 (fun a => P)) (at level 50). *)

  Definition seq: Ord.t -> rel.
    eapply Ord.rec.
    { r. eapply top2. }
    { eapply gf. }
    { i. r. eapply (forall2 a, ds a). }
  Defined.

  Definition cpn_kleene (r: rel) : rel := forall2 o (LE: r <2= seq o), seq o.

  Theorem cpn_kleene_cpn: cpn2 gf = cpn_kleene.
  Proof.
    extensionality r.
    extensionality _x0.
    extensionality _x1.
    eapply prop_ext. split; i.
    - r. ii.
      move a at top. revert_until gf_mon.
      pattern a.
      eapply ClassicOrd.ind.
      + ii. r.
        eapply Ord.rec_is_O in ZERO; eauto.
        rewrite Ord.rec_red.
  Qed.

End THEORY. End THEORY2.
